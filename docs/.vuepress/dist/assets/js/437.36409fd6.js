(window.webpackJsonp=window.webpackJsonp||[]).push([[437],{2108:function(v,e,_){"use strict";_.r(e);var o=_(12),t=Object(o.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"_1-react中hooks的优缺点是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-react中hooks的优缺点是什么"}},[v._v("#")]),v._v(" 1-React中hooks的优缺点是什么")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("react")]),v._v("中,"),_("code",[v._v("hooks")]),v._v("是一个非常抽象的概念,对初学者,往往不是很友好,比较一下"),_("code",[v._v("React")]),v._v("中"),_("code",[v._v("hooks")]),v._v("的优缺点")]),v._v(" "),_("h3",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),_("p",[v._v("[1]. 代码的可读性强,使用"),_("code",[v._v("hooks")]),v._v("之前,发布/订阅自定义事件需要挂载到"),_("code",[v._v("componentDidMount")]),v._v("生命周期上面,然后需要在"),_("code",[v._v("componentWillUnmount")]),v._v("生命周期中清除,在使用"),_("code",[v._v("hooks")]),v._v("之后,通过"),_("code",[v._v("useEffect")]),v._v(",可以把"),_("code",[v._v("componentDidMount")]),v._v("生命周期,"),_("code",[v._v("componentDidUpdate")]),v._v("生命周期,还有"),_("code",[v._v("componentWillUnmount")]),v._v("生命周期集中在一起,方便代码的维护")]),v._v(" "),_("p",[v._v("[2]. 组件的层级更浅,在使用"),_("code",[v._v("hooks")]),v._v("之前,通常使用高阶组件"),_("code",[v._v("Hoc")]),v._v("的方法来实现多个组件共用状态,增强组件的功能,这样是增加了组件渲染的开销,影响了性能,但是在"),_("code",[v._v("Hooks")]),v._v("中可以使用自定义"),_("code",[v._v("hooks")]),v._v("组件"),_("code",[v._v("useXXx()")]),v._v("的方法将多个组件之间共用的状态放到自定义"),_("code",[v._v("hooks")]),v._v("就可以轻松的做到状态的共享")]),v._v(" "),_("p",[v._v("[3]. 不用在考虑"),_("code",[v._v("class")]),v._v("类组件"),_("code",[v._v("this")]),v._v("的指向问题了,在"),_("code",[v._v("hooks")]),v._v("组件中不需要使用"),_("code",[v._v("this.state")]),v._v("来获取数据和方法了")]),v._v(" "),_("p",[v._v("[4]. 可以从组件中提取状态逻辑,使得这些逻辑可以单独测试并复用,"),_("code",[v._v("Hook")]),v._v("使你在无需修改组件结构的情况下复用状态逻辑,这使得在组件间共享"),_("code",[v._v("Hook")]),v._v("变得更便捷，也就是可以大大减少冗余的代码,尤其是针对那些需要复用逻辑的场景")]),v._v(" "),_("p",[v._v("[5]. 没有破坏性改动,"),_("code",[v._v("Hook")]),v._v("不会影响对"),_("code",[v._v("React")]),v._v("概念的理解,"),_("code",[v._v("Hook")]),v._v("为已知的"),_("code",[v._v("React")]),v._v("概念提供了更直接的"),_("code",[v._v("API")]),v._v(","),_("code",[v._v("props")]),v._v(","),_("code",[v._v("state")]),v._v(","),_("code",[v._v("context")]),v._v(","),_("code",[v._v("refs")]),v._v("以及生命周期，同时"),_("code",[v._v("Hook")]),v._v("提供了一种强大的方式来组合它们")]),v._v(" "),_("p",[v._v("[6]. 更易于测试: 由于"),_("code",[v._v("hooks")]),v._v("是纯"),_("code",[v._v("JavaScript")]),v._v("函数,因此他们易于编写单元测试并模拟")]),v._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),_("p",[v._v("[1]. 一个"),_("code",[v._v("useEffect")]),v._v("里面不能写太多东西,把每个不同的功能分给多个"),_("code",[v._v("useEffect")]),v._v("来使用,分成多个模块,把每个功能块分开来写遵循了软件设计当中的单一职责模式,"),_("code",[v._v("hooks")]),v._v("的"),_("code",[v._v("useEffect")]),v._v("只包括"),_("code",[v._v("conponentDidMount")]),v._v(","),_("code",[v._v("componentDidUpdate")]),v._v("和"),_("code",[v._v("componentWillUnmount")]),v._v("这三个生命周期,对于其他的"),_("code",[v._v("class")]),v._v("类组件的生命周期却不支持")]),v._v(" "),_("p",[v._v("[2]. 不要在"),_("code",[v._v("class")]),v._v("组件中调用"),_("code",[v._v("hook")]),v._v(",这样是无效的,不能完全模拟类组件的生命周期,虽然可以使用"),_("code",[v._v("useEffect hook")]),v._v("来模拟,但是它使用起来需要更多的思考和规划")]),v._v(" "),_("p",[v._v("[3]. "),_("code",[v._v("Hooks")]),v._v("是一种新的特性，存在一些兼容性的问题,相对类组件方式,学习曲线比较陡峭,需要一些时间来适应这种编程模式")]),v._v(" "),_("p",[v._v("React中hooks的优点主要是提高了代码的可读性和性能，方便代码的维护和迭代，同时也可以更好地实现状态共享,但是也需要在使用中结合具体的场景和需求来选择最合适的方式,无非就是有了"),_("code",[v._v("hook")]),v._v(",多了一种技术方案选择")]),v._v(" "),_("h2",{attrs:{id:"_2-react事件绑定原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-react事件绑定原理"}},[v._v("#")]),v._v(" 2-React事件绑定原理")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("React")]),v._v("中,事件绑定采用驼峰命名方式,而不是"),_("code",[v._v("DOM")]),v._v("元素中的小写字母命名方式,例如:"),_("code",[v._v("onclick")]),v._v("要写成"),_("code",[v._v("onClick")]),v._v(","),_("code",[v._v("onchange")]),v._v("要写成"),_("code",[v._v("onChange")]),v._v("等")]),v._v(" "),_("p",[_("code",[v._v("React")]),v._v("中绑定的事件不是原生事件,而是由原生事件合成的"),_("code",[v._v("React")]),v._v("事件,例如:"),_("code",[v._v("click")]),v._v("事件合成为"),_("code",[v._v("onClick")]),v._v("事件,"),_("code",[v._v("blur")]),v._v(","),_("code",[v._v("change")]),v._v(","),_("code",[v._v("input")]),v._v(","),_("code",[v._v("keydown")]),v._v(","),_("code",[v._v("keyup")]),v._v("等合成为"),_("code",[v._v("onChange")]),v._v(","),_("code",[v._v("React")]),v._v("这么做的原因是为了消除不同浏览器之间的差异")]),v._v(" "),_("p",[_("code",[v._v("React")]),v._v("事件的工作原理主要分为以下几个步骤")]),v._v(" "),_("p",[v._v("[1]. 收集事件监听器:"),_("code",[v._v("React")]),v._v("会将事件监听器收集到一个数组中,其中包括目标元素的监听器和根元素的监听器")]),v._v(" "),_("p",[v._v("[2]. 获取所有事件:"),_("code",[v._v("React")]),v._v("会将所有事件名处理成"),_("code",[v._v("domEventName")]),v._v("和"),_("code",[v._v("reactEventName")]),v._v(",即"),_("code",[v._v("react")]),v._v("事件名和"),_("code",[v._v("dom")]),v._v("事件名的对应关系")]),v._v(" "),_("p",[_("code",[v._v("React")]),v._v("会遍历"),_("code",[v._v("simpleEventPluginEvents")]),v._v("列表,将事件名处理成"),_("code",[v._v("domEventName")]),v._v("和"),_("code",[v._v("reactEventName")]),v._v(",例如:"),_("code",[v._v("click")]),v._v("事件对应着"),_("code",[v._v("onClick")]),v._v("事件")]),v._v(" "),_("p",[v._v("一共有75个映射关系,"),_("code",[v._v("registationNameDependencies")]),v._v("则保存着"),_("code",[v._v("react")]),v._v("事件名和依赖事件名之间的关系,例如:"),_("code",[v._v("onClick")]),v._v("事件依赖于"),_("code",[v._v("click")]),v._v("事件")]),v._v(" "),_("p",[v._v("[3]. 特殊处理:对于"),_("code",[v._v("onDoubleClick")]),v._v(","),_("code",[v._v("onFocus")]),v._v("和"),_("code",[v._v("onBlur")]),v._v("这三个事件,他们的"),_("code",[v._v("reactEventName")]),v._v("与对应的"),_("code",[v._v("domEventName")]),v._v("不通,因此需要特殊处理")]),v._v(" "),_("p",[v._v("[4]. 收集合成事件:"),_("code",[v._v("React")]),v._v("会将"),_("code",[v._v("event")]),v._v("对象处理成合成事件,为了消除不同浏览器之间的差异,"),_("code",[v._v("React")]),v._v("设计了"),_("code",[v._v("normalize")]),v._v("函数来将"),_("code",[v._v("event")]),v._v("对象处理成合成事件")]),v._v(" "),_("p",[v._v("如果"),_("code",[v._v("normalize")]),v._v("存在,说明"),_("code",[v._v("propName")]),v._v("对应的属性在合成事件中是一个函数,否则,"),_("code",[v._v("propName")]),v._v("对应的属性是一个原生事件")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("React v17")]),v._v("中,"),_("code",[v._v("React")]),v._v("不会在将事件处理添加到"),_("code",[v._v("document")]),v._v("上,而是将事件处理添加到渲染"),_("code",[v._v("React")]),v._v("树的根"),_("code",[v._v("DOM")]),v._v("容器中")]),v._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" rootNode "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" document"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("getElementById")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'root'")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\nReactDOM"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("render")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("App "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("/")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("rootNode"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" \n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[v._v("在"),_("code",[v._v("React16")]),v._v("及之前版本中,"),_("code",[v._v("React")]),v._v("会对大多数事件进行"),_("code",[v._v("document.addEventListener()")]),v._v("操作,"),_("code",[v._v("React V17")]),v._v("开始会通过调用"),_("code",[v._v("rootNode.addEventListener()")]),v._v("来代替")]),v._v(" "),_("p",[v._v("总之,"),_("code",[v._v("React")]),v._v("事件绑定的原理是通过使用合成事件来将浏览器原生事件（如"),_("code",[v._v("click")]),v._v("、"),_("code",[v._v("keyup")]),v._v("等）封装成一个跨浏览器可靠的事件池")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("React")]),v._v("组件中通过使用事件处理函数来监听这些合成事件。"),_("code",[v._v("React")]),v._v("使用了一些优化策略来提高事件绑定的性能和效率")]),v._v(" "),_("p",[v._v("比如，"),_("code",[v._v("React")]),v._v("会在组件卸载时自动销毁事件绑定。另外，"),_("code",[v._v("React")]),v._v("还支持一些高级特性，如事件代理、事件委托以及捕获和冒泡等。")]),v._v(" "),_("p",[v._v("可以通过"),_("code",[v._v("event")]),v._v("对象来获取事件的相关信息，如事件类型、触发元素、按下的键等")]),v._v(" "),_("p",[v._v("在使用"),_("code",[v._v("React")]),v._v("事件绑定时，应该避免直接操作"),_("code",[v._v("DOM")]),v._v("元素，而应该通过调用组件的"),_("code",[v._v("setState")]),v._v("方法来实现状态更新从而触发重新渲染")]),v._v(" "),_("h2",{attrs:{id:"_3-react中setstate是同步还是异步的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-react中setstate是同步还是异步的"}},[v._v("#")]),v._v(" 3-React中setState是同步还是异步的?")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("React")]),v._v("中,"),_("code",[v._v("setState")]),v._v("既可以是同步的也可以是异步的,这取决于执行时机和执行的上下文")]),v._v(" "),_("p",[v._v("[1]. "),_("code",[v._v("setState")]),v._v("的异步并不是指内部由异步代码实现的,实际上执行的过程和代码都是同步的,只是合成事件和钩子函数调用的顺序在更新之前,导致在合成事件和钩子函数中不能立即看到"),_("code",[v._v("state")]),v._v("的变化,而在原生事件和"),_("code",[v._v("setTimeout")]),v._v("中,"),_("code",[v._v("setState")]),v._v("是同步的")]),v._v(" "),_("p",[v._v("[2]. 在"),_("code",[v._v("React17")]),v._v("中,"),_("code",[v._v("setState")]),v._v("是批量执行的,因为执行前会设置"),_("code",[v._v("executionContext")]),v._v(",但如果在"),_("code",[v._v("setTimeout")]),v._v(",事件监听器等函数中,就不会设置"),_("code",[v._v("executionContext")]),v._v("的，这时候"),_("code",[v._v("setState")]),v._v("会同步执行,可以在外面包一层"),_("code",[v._v("batchUpdates")]),v._v("函数,手动设置下"),_("code",[v._v("excutionContext")]),v._v("来切换成异步批量执行")]),v._v(" "),_("p",[v._v("[3]. 在"),_("code",[v._v("React")]),v._v("的渲染流程中,"),_("code",[v._v("setState")]),v._v("会创建"),_("code",[v._v("update")]),v._v("对象挂到"),_("code",[v._v("fiber")]),v._v("对象上,然后耨调度"),_("code",[v._v("performSyncWorkOnRoot")]),v._v("重新渲染,一个主要任务的先后顺序是:"),_("code",[v._v("render")]),v._v("阶段"),_("code",[v._v("render")]),v._v("函数执行--\x3e"),_("code",[v._v("commit")]),v._v("阶段真实"),_("code",[v._v("DOM")]),v._v("替换---\x3e"),_("code",[v._v("setState")]),v._v("回调函数执行"),_("code",[v._v("callback")]),v._v(",因此,可以看出"),_("code",[v._v("setState")]),v._v("的执行顺序是在"),_("code",[v._v("render")]),v._v("之后，"),_("code",[v._v("commit")]),v._v("之前")]),v._v(" "),_("p",[v._v("[4]. 如果"),_("code",[v._v("ExecutionContext")]),v._v("为0,表示当前没有正在进行的其他任务,则"),_("code",[v._v("setState")]),v._v("是同步的,在"),_("code",[v._v("React")]),v._v("的源码中,当"),_("code",[v._v("ExecutionContext")]),v._v("为0时,"),_("code",[v._v("setState")]),v._v("是同步的")]),v._v(" "),_("p",[v._v("[5]. 批量更新:多个顺序的"),_("code",[v._v("setState")]),v._v("不是同步的一个一个执行的,而是会一个一个加入队列,然后最后一起执行,在合成事件和生命周期钩子中,"),_("code",[v._v("setState")]),v._v("更新队列时,存储的是合并状态,因此,前面设置的"),_("code",[v._v("key")]),v._v("值会被后面的覆盖,最终只会执行依次更新")]),v._v(" "),_("p",[v._v("综上所述,"),_("code",[v._v("setState")]),v._v("既可以是同步的也可以是异步的,具体取决于执行时机和执行的上下文,在"),_("code",[v._v("React")]),v._v("中,如果需要手动控制"),_("code",[v._v("setState")]),v._v("的异步执行")]),v._v(" "),_("p",[v._v("也就是在合成事件和生命周期函数中是异步的,在原生事件和定时器中都是同步的,"),_("code",[v._v("setState")]),v._v("本身不分同步或异步,而是取决于是否处于"),_("code",[v._v("batch update")]),v._v("中")]),v._v(" "),_("p",[v._v("可以使用"),_("code",[v._v("batchUpdates")]),v._v("函数手动设置"),_("code",[v._v("excutionContext")]),v._v("来切换成异步批量执行,同时,在合成事件和生命周期钩子中,"),_("code",[v._v("setState")]),v._v("更新队列时,会存储合并状态,因此需要注意"),_("code",[v._v("key")]),v._v("值的覆盖问题")])])}),[],!1,null,null,null);e.default=t.exports}}]);